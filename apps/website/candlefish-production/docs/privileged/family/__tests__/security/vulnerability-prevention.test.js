/**
 * Security Vulnerability Prevention Tests
 * Tests for common security vulnerabilities and attack vectors
 */

const request = require('supertest');
const { createMockApp } = require('../api/auth-endpoints.test');

describe('Security Vulnerability Tests', () => {
    let app;
    let validToken;

    beforeEach(async () => {
        app = createMockApp();
        
        // Get valid token for authenticated tests
        const loginResponse = await request(app)
            .post('/api/auth/login')
            .send({
                email: 'family@candlefish-ai.com',
                password: 'family-secure-2025'
            });
        
        validToken = loginResponse.body.token;
    });

    describe('Authentication Security', () => {
        test('should prevent brute force attacks with rate limiting', async () => {
            const attackAttempts = Array(10).fill().map(() =>
                request(app)
                    .post('/api/auth/login')
                    .send({
                        email: 'family@candlefish-ai.com',
                        password: 'wrong-password'
                    })
            );

            const responses = await Promise.all(attackAttempts);

            // Later requests should be rate limited
            const rateLimitedCount = responses.filter(r => r.status === 429).length;
            expect(rateLimitedCount).toBeGreaterThan(0);

            // Rate limited responses should include proper headers
            const rateLimitedResponse = responses.find(r => r.status === 429);
            expect(rateLimitedResponse.body.error).toContain('Too many authentication attempts');
            expect(rateLimitedResponse.body.retryAfter).toBeGreaterThan(0);
        });

        test('should prevent timing attacks by consistent response times', async () => {
            const startTime = Date.now();
            
            // Test with non-existent user
            const nonExistentResponse = await request(app)
                .post('/api/auth/login')
                .send({
                    email: 'nonexistent@candlefish-ai.com',
                    password: 'any-password'
                });
            
            const nonExistentTime = Date.now() - startTime;

            // Test with existing user but wrong password
            const wrongPasswordStart = Date.now();
            const wrongPasswordResponse = await request(app)
                .post('/api/auth/login')
                .send({
                    email: 'family@candlefish-ai.com',
                    password: 'wrong-password'
                });
            
            const wrongPasswordTime = Date.now() - wrongPasswordStart;

            // Both should return 401 and take similar time
            expect(nonExistentResponse.status).toBe(401);
            expect(wrongPasswordResponse.status).toBe(401);
            
            // Response times should be similar (within 100ms)
            const timeDifference = Math.abs(nonExistentTime - wrongPasswordTime);
            expect(timeDifference).toBeLessThan(100);
        });

        test('should prevent password enumeration', async () => {
            // Test with various email formats
            const testEmails = [
                'nonexistent@candlefish-ai.com',
                'family@candlefish-ai.com', // Valid email
                'invalid-email-format',
                'admin@other-domain.com'
            ];

            const responses = await Promise.all(
                testEmails.map(email =>
                    request(app)
                        .post('/api/auth/login')
                        .send({
                            email: email,
                            password: 'wrong-password'
                        })
                )
            );

            // All invalid attempts should return similar error messages
            const invalidResponses = responses.filter(r => r.status === 401 || r.status === 400);
            
            // Should not reveal whether email exists or not
            invalidResponses.forEach(response => {
                if (response.status === 401) {
                    expect(response.body.error).toBe('Invalid credentials');
                    expect(response.body.code).toBe('INVALID_CREDENTIALS');
                }
            });
        });

        test('should validate input length and prevent buffer overflow attempts', async () => {
            const longString = 'a'.repeat(10000); // 10KB string
            const veryLongString = 'a'.repeat(100000); // 100KB string

            // Test long email
            const longEmailResponse = await request(app)
                .post('/api/auth/login')
                .send({
                    email: longString,
                    password: 'password'
                });

            expect(longEmailResponse.status).toBe(400);

            // Test very long password
            const longPasswordResponse = await request(app)
                .post('/api/auth/login')
                .send({
                    email: 'test@example.com',
                    password: veryLongString
                });

            // Should handle gracefully without crashing
            expect([400, 401, 413]).toContain(longPasswordResponse.status);
        });
    });

    describe('Input Validation and Sanitization', () => {
        test('should prevent SQL injection attempts', async () => {
            const sqlInjectionPayloads = [
                \"'; DROP TABLE users; --\",
                \"admin'--\",
                \"' OR 1=1 --\",
                \"'; INSERT INTO users VALUES ('hacker', 'password'); --\",
                \"' UNION SELECT * FROM passwords --\"
            ];

            for (const payload of sqlInjectionPayloads) {
                const response = await request(app)
                    .post('/api/auth/login')
                    .send({
                        email: payload,
                        password: 'password'
                    });

                // Should reject malicious input
                expect([400, 401]).toContain(response.status);
                
                // Should not execute SQL
                if (response.status === 400) {
                    expect(response.body.error).toContain('Invalid email format');
                } else {
                    expect(response.body.error).toBe('Invalid credentials');
                }
            }
        });

        test('should prevent XSS attacks in form inputs', async () => {
            const xssPayloads = [
                '<script>alert(\"XSS\")</script>',
                '<img src=x onerror=alert(\"XSS\")>',
                'javascript:alert(\"XSS\")',
                '<svg onload=alert(\"XSS\")>',
                '\"><script>alert(\"XSS\")</script>'
            ];

            for (const payload of xssPayloads) {
                const response = await request(app)
                    .post('/api/auth/login')
                    .send({
                        email: payload,
                        password: 'password'
                    });

                // Should sanitize or reject XSS attempts
                expect([400, 401]).toContain(response.status);
                
                // Response should not contain unsanitized script tags
                const responseText = JSON.stringify(response.body);
                expect(responseText).not.toContain('<script>');
                expect(responseText).not.toContain('javascript:');
                expect(responseText).not.toContain('onerror=');
            }
        });

        test('should prevent LDAP injection attempts', async () => {
            const ldapInjectionPayloads = [
                'admin)(&(password=*))',
                'admin)(|(password=*))',
                '*)(uid=*))(|(uid=*',
                'admin))(|(|(password=*))(password=*)),
                '*)(&(objectClass=*))'
            ];

            for (const payload of ldapInjectionPayloads) {
                const response = await request(app)
                    .post('/api/auth/login')
                    .send({
                        email: payload,
                        password: 'password'
                    });

                // Should reject LDAP injection attempts
                expect([400, 401]).toContain(response.status);
            }
        });

        test('should prevent command injection attempts', async () => {
            const commandInjectionPayloads = [
                'test@example.com; cat /etc/passwd',
                'test@example.com && rm -rf /',
                'test@example.com | whoami',
                'test@example.com `id`',
                'test@example.com $(whoami)'
            ];

            for (const payload of commandInjectionPayloads) {
                const response = await request(app)
                    .post('/api/auth/login')
                    .send({
                        email: payload,
                        password: 'password'
                    });

                // Should reject command injection attempts
                expect([400, 401]).toContain(response.status);
            }
        });
    });

    describe('Token Security', () => {
        test('should prevent JWT token manipulation', async () => {
            // Test with modified JWT payload
            const tokenParts = validToken.split('.');
            const header = tokenParts[0];
            const payload = Buffer.from(tokenParts[1], 'base64').toString();
            const signature = tokenParts[2];

            // Modify payload to escalate privileges
            const modifiedPayload = JSON.parse(payload);
            modifiedPayload.role = 'admin';
            modifiedPayload.userId = 1;

            const modifiedTokenPayload = Buffer.from(JSON.stringify(modifiedPayload)).toString('base64');
            const modifiedToken = `${header}.${modifiedTokenPayload}.${signature}`;

            const response = await request(app)
                .get('/api/documents/FAM-2025-001')
                .set('Authorization', `Bearer ${modifiedToken}`);

            // Should reject modified token due to invalid signature
            expect(response.status).toBe(403);
            expect(response.body.error).toBe('Invalid or expired token');
        });

        test('should prevent token replay attacks', async () => {
            // Use same token multiple times rapidly
            const rapidRequests = Array(10).fill().map(() =>
                request(app)
                    .get('/api/documents/FAM-2025-001')
                    .set('Authorization', `Bearer ${validToken}`)
            );

            const responses = await Promise.all(rapidRequests);

            // All should succeed (no replay protection in mock)
            // In real implementation, could implement nonce or timestamp checking
            responses.forEach(response => {
                expect(response.status).toBe(200);
            });

            // Document timestamp-based replay protection
            const oldTimestamp = Date.now() - (60 * 60 * 1000); // 1 hour ago
            
            // This test documents expected behavior for timestamp validation
            expect(Date.now() - oldTimestamp).toBeGreaterThan(30 * 60 * 1000); // 30 minutes
        });

        test('should handle token without proper claims', async () => {
            // Create token without required claims
            const jwt = require('jsonwebtoken');
            const incompleteToken = jwt.sign(
                {
                    // Missing userId, email, role
                    exp: Math.floor(Date.now() / 1000) + 3600
                },
                'test-secret-key'
            );

            const response = await request(app)
                .get('/api/documents/FAM-2025-001')
                .set('Authorization', `Bearer ${incompleteToken}`);

            // Should handle gracefully
            expect([401, 403, 500]).toContain(response.status);
        });
    });

    describe('HTTP Security Headers', () => {
        test('should include security headers in responses', async () => {
            const response = await request(app)
                .post('/api/auth/login')
                .send({
                    email: 'family@candlefish-ai.com',
                    password: 'family-secure-2025'
                });

            // In a real implementation, these headers should be present
            // expect(response.headers['x-content-type-options']).toBe('nosniff');
            // expect(response.headers['x-frame-options']).toBe('DENY');
            // expect(response.headers['x-xss-protection']).toBe('1; mode=block');
            // expect(response.headers['strict-transport-security']).toBeDefined();
            // expect(response.headers['content-security-policy']).toBeDefined();

            // For now, document expected behavior
            expect(response.status).toBe(200);
        });

        test('should prevent clickjacking with proper headers', async () => {
            const response = await request(app)
                .get('/api/documents/FAM-2025-001')
                .set('Authorization', `Bearer ${validToken}`);

            // Should include X-Frame-Options or CSP frame-ancestors
            // expect(response.headers['x-frame-options']).toMatch(/(DENY|SAMEORIGIN)/);
            
            expect(response.status).toBe(200);
        });
    });

    describe('Session Security', () => {
        test('should prevent session fixation attacks', async () => {
            // Test that new session is created after login
            const preLoginResponse = await request(app)
                .post('/api/auth/login')
                .send({
                    email: 'family@candlefish-ai.com',
                    password: 'family-secure-2025'
                });

            expect(preLoginResponse.body.sessionId).toBeDefined();
            
            const sessionId1 = preLoginResponse.body.sessionId;

            // Login again - should get different session
            const postLoginResponse = await request(app)
                .post('/api/auth/login')
                .send({
                    email: 'family@candlefish-ai.com',
                    password: 'family-secure-2025'
                });

            const sessionId2 = postLoginResponse.body.sessionId;

            // Session IDs should be different
            expect(sessionId1).not.toBe(sessionId2);
        });

        test('should handle concurrent sessions properly', async () => {
            // Create multiple sessions for same user
            const session1 = await request(app)
                .post('/api/auth/login')
                .send({
                    email: 'family@candlefish-ai.com',
                    password: 'family-secure-2025'
                });

            const session2 = await request(app)
                .post('/api/auth/login')
                .send({
                    email: 'family@candlefish-ai.com',
                    password: 'family-secure-2025'
                });

            // Both sessions should be valid
            expect(session1.body.success).toBe(true);
            expect(session2.body.success).toBe(true);
            expect(session1.body.sessionId).not.toBe(session2.body.sessionId);

            // Both tokens should work
            const doc1Response = await request(app)
                .get('/api/documents/FAM-2025-001')
                .set('Authorization', `Bearer ${session1.body.token}`);

            const doc2Response = await request(app)
                .get('/api/documents/FAM-2025-001')
                .set('Authorization', `Bearer ${session2.body.token}`);

            expect(doc1Response.status).toBe(200);
            expect(doc2Response.status).toBe(200);
        });

        test('should prevent session hijacking', async () => {
            // This test documents expected behavior for session security
            
            // Simulate stolen session token
            const stolenToken = validToken;
            
            // In real implementation, would check:
            // - IP address consistency
            // - User agent consistency
            // - Geolocation consistency
            // - Behavior patterns
            
            const response = await request(app)
                .get('/api/documents/FAM-2025-001')
                .set('Authorization', `Bearer ${stolenToken}`)
                .set('User-Agent', 'DifferentBrowser/1.0')
                .set('X-Forwarded-For', '192.168.1.100'); // Different IP

            // In mock, this succeeds, but real implementation should validate
            expect(response.status).toBe(200);
            
            // Real implementation should log suspicious activity
            expect(true).toBe(true); // Placeholder for logging verification
        });
    });

    describe('API Endpoint Security', () => {
        test('should prevent unauthorized document access', async () => {
            // Test access without token
            const noTokenResponse = await request(app)
                .get('/api/documents/FAM-2025-001');

            expect(noTokenResponse.status).toBe(401);
            expect(noTokenResponse.body.error).toBe('Access token required');

            // Test access with invalid token
            const invalidTokenResponse = await request(app)
                .get('/api/documents/FAM-2025-001')
                .set('Authorization', 'Bearer invalid.token.here');

            expect(invalidTokenResponse.status).toBe(403);
            expect(invalidTokenResponse.body.error).toBe('Invalid or expired token');
        });

        test('should prevent path traversal attacks', async () => {
            const pathTraversalPayloads = [
                '../../../etc/passwd',
                '..\\\\..\\\\..\\\\windows\\\\system32\\\\config\\\\sam',
                '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
                '....//....//....//etc/passwd'
            ];

            for (const payload of pathTraversalPayloads) {
                const response = await request(app)
                    .get(`/api/documents/${payload}`)
                    .set('Authorization', `Bearer ${validToken}`);

                // Should return 404 for non-existent documents, not expose system files
                expect(response.status).toBe(404);
                expect(response.body.error).toBe('Document not found');
                
                // Should not contain system file content
                expect(response.body).not.toHaveProperty('passwd');
                expect(response.body).not.toHaveProperty('root');
            }
        });

        test('should prevent HTTP method tampering', async () => {
            // Test GET request to login endpoint
            const getLoginResponse = await request(app)
                .get('/api/auth/login');

            expect(getLoginResponse.status).toBe(404);

            // Test PUT request to document endpoint
            const putDocResponse = await request(app)
                .put('/api/documents/FAM-2025-001')
                .set('Authorization', `Bearer ${validToken}`)
                .send({ malicious: 'data' });

            expect(putDocResponse.status).toBe(404);

            // Test DELETE request to protected endpoint
            const deleteResponse = await request(app)
                .delete('/api/documents/FAM-2025-001')
                .set('Authorization', `Bearer ${validToken}`);

            expect(deleteResponse.status).toBe(404);
        });

        test('should validate content-type headers', async () => {
            // Test login with wrong content type
            const wrongContentTypeResponse = await request(app)
                .post('/api/auth/login')
                .set('Content-Type', 'text/plain')
                .send('email=test@example.com&password=password');

            // Should reject non-JSON content for JSON endpoints
            expect([400, 415]).toContain(wrongContentTypeResponse.status);

            // Test with XML payload
            const xmlResponse = await request(app)
                .post('/api/auth/login')
                .set('Content-Type', 'application/xml')
                .send('<credentials><email>test@example.com</email></credentials>');

            expect([400, 415]).toContain(xmlResponse.status);
        });
    });

    describe('Data Protection', () => {
        test('should not expose sensitive information in error messages', async () => {
            // Test various error scenarios
            const errorTests = [
                {
                    request: () => request(app).post('/api/auth/login').send({}),
                    description: 'missing credentials'
                },
                {
                    request: () => request(app).post('/api/auth/login').send({
                        email: 'invalid',
                        password: 'test'
                    }),
                    description: 'invalid email format'
                },
                {
                    request: () => request(app).get('/api/documents/nonexistent')
                        .set('Authorization', `Bearer ${validToken}`),
                    description: 'nonexistent document'
                }
            ];

            for (const test of errorTests) {
                const response = await test.request();
                
                // Error messages should not contain:
                const responseText = JSON.stringify(response.body).toLowerCase();
                
                // Database connection strings
                expect(responseText).not.toContain('database');
                expect(responseText).not.toContain('connection');
                expect(responseText).not.toContain('mysql');
                expect(responseText).not.toContain('postgres');
                
                // File paths
                expect(responseText).not.toContain('/var/');
                expect(responseText).not.toContain('c:\\\\');
                expect(responseText).not.toContain('/home/');
                
                // Internal system information
                expect(responseText).not.toContain('stack trace');
                expect(responseText).not.toContain('node_modules');
                expect(responseText).not.toContain('at async');
            }
        });

        test('should sanitize user data in logs', async () => {
            // Simulate logging of user input
            const sensitiveData = {
                email: 'user@example.com',
                password: 'secretpassword123',
                ssn: '123-45-6789',
                creditCard: '4111-1111-1111-1111'
            };

            // In real implementation, logging should sanitize sensitive data
            const sanitizeSensitiveData = (data) => {
                const sanitized = { ...data };
                if (sanitized.password) sanitized.password = '[REDACTED]';
                if (sanitized.ssn) sanitized.ssn = '[REDACTED]';
                if (sanitized.creditCard) sanitized.creditCard = '[REDACTED]';
                return sanitized;
            };

            const sanitized = sanitizeSensitiveData(sensitiveData);
            
            expect(sanitized.email).toBe('user@example.com');
            expect(sanitized.password).toBe('[REDACTED]');
            expect(sanitized.ssn).toBe('[REDACTED]');
            expect(sanitized.creditCard).toBe('[REDACTED]');
        });

        test('should handle sensitive data in memory securely', async () => {
            // Test that sensitive data is not lingering in memory
            let sensitiveString = 'password123';
            
            // In real implementation, would use secure string handling
            const clearSensitiveString = (str) => {
                // JavaScript doesn't allow direct memory manipulation
                // but documents expected behavior for languages that do
                return str.replace(/./g, '0');
            };

            const cleared = clearSensitiveString(sensitiveString);
            expect(cleared).toBe('000000000000');
            
            // Clear reference
            sensitiveString = null;
            expect(sensitiveString).toBeNull();
        });
    });

    describe('Denial of Service Protection', () => {
        test('should handle large request payloads', async () => {
            const largePayload = {
                email: 'test@example.com',
                password: 'password',
                largeField: 'x'.repeat(1000000) // 1MB
            };

            const response = await request(app)
                .post('/api/auth/login')
                .send(largePayload);

            // Should either reject large payloads or handle gracefully
            expect([400, 413, 500]).toContain(response.status);
        });

        test('should prevent regex denial of service (ReDoS)', async () => {
            // Test with patterns that could cause exponential backtracking
            const redosPayloads = [
                'a'.repeat(100000) + 'X', // Long string that doesn't match
                '((a+)+)+b', // Nested quantifiers
                '(a|a)*b' // Alternation with overlap
            ];

            for (const payload of redosPayloads) {
                const startTime = Date.now();
                
                const response = await request(app)
                    .post('/api/auth/login')
                    .send({
                        email: payload,
                        password: 'password'
                    });

                const duration = Date.now() - startTime;
                
                // Should not take excessive time (> 5 seconds indicates ReDoS)
                expect(duration).toBeLessThan(5000);
                expect([400, 401]).toContain(response.status);
            }
        });

        test('should handle concurrent request limits', async () => {
            // Create many concurrent requests
            const concurrentRequests = Array(50).fill().map(() =>
                request(app)
                    .post('/api/auth/login')
                    .send({
                        email: 'family@candlefish-ai.com',
                        password: 'family-secure-2025'
                    })
            );

            const startTime = Date.now();
            const responses = await Promise.all(concurrentRequests);
            const duration = Date.now() - startTime;

            // Should handle concurrent requests without excessive delay
            expect(duration).toBeLessThan(10000); // 10 seconds

            // Most requests should succeed (rate limiting may kick in)
            const successfulRequests = responses.filter(r => r.status === 200);
            expect(successfulRequests.length).toBeGreaterThan(0);
        });
    });
});