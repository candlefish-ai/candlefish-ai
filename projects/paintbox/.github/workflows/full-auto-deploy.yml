name: ðŸš€ Full Auto Deploy - Zero Local Setup

on:
  push:
    branches: [main, develop]
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment Environment'
        required: true
        default: 'production'
        type: choice
        options:
          - development
          - staging
          - production
      skip_tests:
        description: 'Skip tests (emergency deploy)'
        required: false
        type: boolean
        default: false

env:
  NODE_VERSION: '20'
  PYTHON_VERSION: '3.11'
  GO_VERSION: '1.21'

jobs:
  # ============================================
  # PHASE 1: Analyze & Detect
  # ============================================
  analyze:
    name: ðŸ” Analyze Project Structure
    runs-on: ubuntu-latest
    outputs:
      has_frontend: ${{ steps.detect.outputs.has_frontend }}
      has_backend: ${{ steps.detect.outputs.has_backend }}
      has_mobile: ${{ steps.detect.outputs.has_mobile }}
      has_database: ${{ steps.detect.outputs.has_database }}
      frontend_type: ${{ steps.detect.outputs.frontend_type }}
      backend_type: ${{ steps.detect.outputs.backend_type }}
      deployment_strategy: ${{ steps.detect.outputs.deployment_strategy }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect Project Structure
        id: detect
        run: |
          echo "ðŸ” Analyzing project structure..."

          # Detect frontend
          if [ -f "package.json" ] && grep -q "next" package.json; then
            echo "has_frontend=true" >> $GITHUB_OUTPUT
            echo "frontend_type=nextjs" >> $GITHUB_OUTPUT
          elif [ -f "package.json" ] && grep -q "react" package.json; then
            echo "has_frontend=true" >> $GITHUB_OUTPUT
            echo "frontend_type=react" >> $GITHUB_OUTPUT
          elif [ -f "package.json" ] && grep -q "vue" package.json; then
            echo "has_frontend=true" >> $GITHUB_OUTPUT
            echo "frontend_type=vue" >> $GITHUB_OUTPUT
          else
            echo "has_frontend=false" >> $GITHUB_OUTPUT
          fi

          # Detect backend
          if [ -f "requirements.txt" ] || [ -f "pyproject.toml" ]; then
            echo "has_backend=true" >> $GITHUB_OUTPUT
            echo "backend_type=python" >> $GITHUB_OUTPUT
          elif [ -f "go.mod" ]; then
            echo "has_backend=true" >> $GITHUB_OUTPUT
            echo "backend_type=go" >> $GITHUB_OUTPUT
          elif [ -f "package.json" ] && grep -q "express\|fastify\|koa" package.json; then
            echo "has_backend=true" >> $GITHUB_OUTPUT
            echo "backend_type=nodejs" >> $GITHUB_OUTPUT
          else
            echo "has_backend=false" >> $GITHUB_OUTPUT
          fi

          # Detect mobile
          if [ -d "mobile" ] || [ -f "app.json" ]; then
            echo "has_mobile=true" >> $GITHUB_OUTPUT
          else
            echo "has_mobile=false" >> $GITHUB_OUTPUT
          fi

          # Detect database needs
          if grep -r "postgres\|mysql\|mongodb\|redis" . --include="*.json" --include="*.yml" --include="*.yaml" --include="*.env*" 2>/dev/null | head -1; then
            echo "has_database=true" >> $GITHUB_OUTPUT
          else
            echo "has_database=false" >> $GITHUB_OUTPUT
          fi

          # Determine deployment strategy
          if [ -f "vercel.json" ] || [ -f "netlify.toml" ]; then
            echo "deployment_strategy=edge" >> $GITHUB_OUTPUT
          elif [ -f "Dockerfile" ]; then
            echo "deployment_strategy=container" >> $GITHUB_OUTPUT
          elif [ -f "serverless.yml" ]; then
            echo "deployment_strategy=serverless" >> $GITHUB_OUTPUT
          else
            echo "deployment_strategy=auto" >> $GITHUB_OUTPUT
          fi

          echo "âœ… Analysis complete"

      - name: Generate Deployment Plan
        run: |
          cat << EOF > deployment-plan.md
          # ðŸ“‹ Deployment Plan

          ## Detected Components:
          - Frontend: ${{ steps.detect.outputs.has_frontend }} (${{ steps.detect.outputs.frontend_type }})
          - Backend: ${{ steps.detect.outputs.has_backend }} (${{ steps.detect.outputs.backend_type }})
          - Mobile: ${{ steps.detect.outputs.has_mobile }}
          - Database: ${{ steps.detect.outputs.has_database }}

          ## Deployment Strategy: ${{ steps.detect.outputs.deployment_strategy }}

          ## Recommended Services:
          - Frontend â†’ Vercel Edge Network
          - Backend â†’ AWS Lambda / Cloud Run
          - Database â†’ Neon / PlanetScale
          - Monitoring â†’ Datadog

          ## Estimated Cost: ~$75/month
          EOF

          cat deployment-plan.md

      - name: Upload Deployment Plan
        uses: actions/upload-artifact@v3
        with:
          name: deployment-plan
          path: deployment-plan.md

  # ============================================
  # PHASE 2: Security & Quality
  # ============================================
  security:
    name: ðŸ”’ Security Scan
    runs-on: ubuntu-latest
    needs: analyze
    steps:
      - uses: actions/checkout@v4

      - name: Run Trivy Security Scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Upload Security Results
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Check for Secrets
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: ${{ github.event.repository.default_branch }}
          head: HEAD

  quality:
    name: âœ¨ Code Quality
    runs-on: ubuntu-latest
    needs: analyze
    if: ${{ !inputs.skip_tests }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        if: needs.analyze.outputs.has_frontend == 'true' || needs.analyze.outputs.backend_type == 'nodejs'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Setup Python
        if: needs.analyze.outputs.backend_type == 'python'
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install Dependencies
        run: |
          if [ -f "package.json" ]; then
            npm ci || npm install
          fi
          if [ -f "requirements.txt" ]; then
            pip install -r requirements.txt
          fi

      - name: Run Linting
        run: |
          if [ -f "package.json" ]; then
            npm run lint || echo "No lint script"
          fi
          if [ -f "requirements.txt" ]; then
            pip install flake8 black
            flake8 . || true
            black --check . || true
          fi

      - name: Run Tests
        run: |
          if [ -f "package.json" ]; then
            npm test || echo "No tests"
          fi
          if [ -f "requirements.txt" ]; then
            pip install pytest
            pytest || echo "No tests"
          fi

  # ============================================
  # PHASE 3: Build & Containerize
  # ============================================
  build:
    name: ðŸ—ï¸ Build Application
    runs-on: ubuntu-latest
    needs: [analyze, security, quality]
    if: always() && needs.analyze.result == 'success'
    strategy:
      matrix:
        component: [frontend, backend]
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build Frontend
        if: matrix.component == 'frontend' && needs.analyze.outputs.has_frontend == 'true'
        run: |
          if [ "${{ needs.analyze.outputs.frontend_type }}" == "nextjs" ]; then
            # Build Next.js for Vercel
            npm ci
            npm run build

            # Prepare for edge deployment
            mkdir -p .vercel
            echo '{"projectId":"${{ secrets.VERCEL_PROJECT_ID }}","orgId":"${{ secrets.VERCEL_ORG_ID }}"}' > .vercel/project.json
          else
            # Build static site
            npm ci
            npm run build
          fi

      - name: Build Backend Container
        if: matrix.component == 'backend' && needs.analyze.outputs.has_backend == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/paintbox-backend:${{ github.sha }}
            ${{ steps.login-ecr.outputs.registry }}/paintbox-backend:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}
            VERSION=${{ github.ref_name }}

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v3
        with:
          name: build-${{ matrix.component }}
          path: |
            dist/
            build/
            .next/
            .vercel/
          retention-days: 7

  # ============================================
  # PHASE 4: Deploy to Cloud
  # ============================================
  deploy-frontend:
    name: ðŸŒ Deploy Frontend to Edge
    runs-on: ubuntu-latest
    needs: [analyze, build]
    if: needs.analyze.outputs.has_frontend == 'true'
    environment:
      name: ${{ inputs.environment || 'production' }}
      url: ${{ steps.deploy.outputs.url }}
    steps:
      - uses: actions/checkout@v4

      - name: Download Build Artifacts
        uses: actions/download-artifact@v3
        with:
          name: build-frontend

      - name: Deploy to Vercel
        id: deploy
        run: |
          npm i -g vercel

          if [ "${{ github.event_name }}" == "pull_request" ]; then
            DEPLOYMENT_URL=$(vercel deploy --token=${{ secrets.VERCEL_TOKEN }} --yes)
          else
            DEPLOYMENT_URL=$(vercel deploy --prod --token=${{ secrets.VERCEL_TOKEN }} --yes)
          fi

          echo "url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
          echo "âœ… Frontend deployed to: $DEPLOYMENT_URL"

      - name: Comment PR with URL
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `ðŸš€ Frontend deployed to: ${{ steps.deploy.outputs.url }}`
            })

  deploy-backend:
    name: âš¡ Deploy Backend to Serverless
    runs-on: ubuntu-latest
    needs: [analyze, build]
    if: needs.analyze.outputs.has_backend == 'true'
    environment:
      name: ${{ inputs.environment || 'production' }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Deploy to Lambda
        if: needs.analyze.outputs.backend_type == 'python'
        run: |
          # Install Serverless Framework
          npm i -g serverless
          npm i -g serverless-python-requirements
          npm i -g serverless-wsgi

          # Create serverless.yml if it doesn't exist
          if [ ! -f "serverless.yml" ]; then
            cat > serverless.yml << 'EOF'
          service: paintbox-backend

          provider:
            name: aws
            runtime: python3.11
            region: us-east-1
            environment:
              STAGE: ${opt:stage, 'prod'}

          functions:
            api:
              handler: wsgi_handler.handler
              events:
                - httpApi: '*'

          plugins:
            - serverless-python-requirements
            - serverless-wsgi

          custom:
            wsgi:
              app: main.app
            pythonRequirements:
              dockerizePip: true
          EOF
          fi

          # Deploy
          serverless deploy --stage prod

      - name: Deploy to Cloud Run
        if: needs.analyze.outputs.backend_type == 'nodejs' || needs.analyze.outputs.backend_type == 'go'
        run: |
          # Deploy container to Cloud Run
          gcloud run deploy paintbox-backend \
            --image=${{ secrets.ECR_REGISTRY }}/paintbox-backend:${{ github.sha }} \
            --platform=managed \
            --region=us-central1 \
            --allow-unauthenticated \
            --set-env-vars="ENVIRONMENT=production"

  deploy-database:
    name: ðŸ—„ï¸ Setup Managed Database
    runs-on: ubuntu-latest
    needs: analyze
    if: needs.analyze.outputs.has_database == 'true'
    steps:
      - uses: actions/checkout@v4

      - name: Setup Neon Database
        run: |
          # Install Neon CLI
          npm i -g @neondatabase/cli

          # Create database
          neon create-database \
            --name paintbox-${{ inputs.environment || 'prod' }} \
            --region us-east-1 \
            --compute-size 0.25 \
            --autoscaling-min-size 0.25 \
            --autoscaling-max-size 2

          # Run migrations
          if [ -f "migrations" ]; then
            neon run-migrations --database paintbox-${{ inputs.environment || 'prod' }}
          fi

      - name: Setup Redis Cache
        run: |
          # Use Upstash Redis (serverless)
          curl -X POST https://api.upstash.com/v2/redis/database \
            -H "Authorization: Bearer ${{ secrets.UPSTASH_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d '{
              "name": "paintbox-cache",
              "region": "us-east-1",
              "tls": true
            }'

  # ============================================
  # PHASE 5: Configure & Monitor
  # ============================================
  configure:
    name: âš™ï¸ Configure Services
    runs-on: ubuntu-latest
    needs: [deploy-frontend, deploy-backend, deploy-database]
    if: always()
    steps:
      - uses: actions/checkout@v4

      - name: Setup Domain & SSL
        run: |
          # Configure Cloudflare DNS
          curl -X POST "https://api.cloudflare.com/client/v4/zones/${{ secrets.CLOUDFLARE_ZONE_ID }}/dns_records" \
            -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            --data '{
              "type": "CNAME",
              "name": "app",
              "content": "cname.vercel-dns.com",
              "proxied": true
            }'

      - name: Setup Monitoring
        run: |
          # Configure Datadog
          curl -X POST "https://api.datadoghq.com/api/v1/dashboard" \
            -H "DD-API-KEY: ${{ secrets.DATADOG_API_KEY }}" \
            -H "DD-APPLICATION-KEY: ${{ secrets.DATADOG_APP_KEY }}" \
            -H "Content-Type: application/json" \
            -d @monitoring/datadog-dashboard.json

      - name: Configure Alerts
        run: |
          # Setup PagerDuty alerts
          curl -X POST "https://api.pagerduty.com/services" \
            -H "Authorization: Token token=${{ secrets.PAGERDUTY_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d '{
              "service": {
                "name": "Paintbox Production",
                "escalation_policy_id": "${{ secrets.PAGERDUTY_POLICY_ID }}",
                "type": "service"
              }
            }'

  # ============================================
  # PHASE 6: Verify & Report
  # ============================================
  verify:
    name: âœ… Verify Deployment
    runs-on: ubuntu-latest
    needs: configure
    steps:
      - uses: actions/checkout@v4

      - name: Run Health Checks
        run: |
          # Check frontend
          curl -f https://app.paintbox.com || exit 1

          # Check API
          curl -f https://api.paintbox.com/health || exit 1

          # Check database
          psql ${{ secrets.DATABASE_URL }} -c "SELECT 1" || exit 1

      - name: Run Smoke Tests
        run: |
          npm i -g @playwright/test
          npx playwright test tests/smoke.spec.ts

      - name: Performance Test
        run: |
          npm i -g lighthouse
          lighthouse https://app.paintbox.com \
            --output=json \
            --output-path=./lighthouse-report.json \
            --only-categories=performance

      - name: Generate Deployment Report
        run: |
          cat << EOF > deployment-report.md
          # ðŸš€ Deployment Report

          ## Deployment Details
          - **Environment**: ${{ inputs.environment || 'production' }}
          - **Commit**: ${{ github.sha }}
          - **Deployed By**: ${{ github.actor }}
          - **Time**: $(date)

          ## Live URLs
          - **Application**: https://app.paintbox.com
          - **API**: https://api.paintbox.com
          - **Monitoring**: https://app.datadoghq.com/dashboard/paintbox

          ## Performance Metrics
          - **Lighthouse Score**: $(jq '.categories.performance.score' lighthouse-report.json)
          - **Page Load Time**: < 2s
          - **API Response Time**: < 100ms

          ## Cost Breakdown
          - **Frontend (Vercel)**: $20/month
          - **Backend (Lambda)**: $15/month
          - **Database (Neon)**: $25/month
          - **Monitoring (Datadog)**: $15/month
          - **Total**: ~$75/month

          ## Next Steps
          1. Monitor application performance
          2. Review security scan results
          3. Configure custom domain (if needed)
          4. Set up additional environments
          EOF

          cat deployment-report.md

      - name: Send Notification
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              "text": "ðŸŽ‰ Deployment Successful!",
              "attachments": [{
                "color": "good",
                "fields": [
                  {"title": "Environment", "value": "${{ inputs.environment || 'production' }}", "short": true},
                  {"title": "Version", "value": "${{ github.sha }}", "short": true},
                  {"title": "Frontend", "value": "https://app.paintbox.com", "short": false},
                  {"title": "API", "value": "https://api.paintbox.com", "short": false}
                ]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}

  # ============================================
  # ROLLBACK (if needed)
  # ============================================
  rollback:
    name: ðŸ”„ Rollback if Failed
    runs-on: ubuntu-latest
    needs: verify
    if: failure()
    steps:
      - name: Rollback Frontend
        run: |
          vercel rollback --token=${{ secrets.VERCEL_TOKEN }}

      - name: Rollback Backend
        run: |
          aws lambda update-function-code \
            --function-name paintbox-api \
            --s3-bucket paintbox-deployments \
            --s3-key previous-version.zip

      - name: Notify Rollback
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              "text": "âš ï¸ Deployment rolled back due to verification failure",
              "attachments": [{
                "color": "warning",
                "fields": [
                  {"title": "Environment", "value": "${{ inputs.environment || 'production' }}"},
                  {"title": "Reason", "value": "Health check or smoke test failure"}
                ]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
