#!/usr/bin/env ts-node
/**\n * Excel Parity Testing Script\n * Tests the formula engine against original Excel calculations\n * Validates all 14,683 formulas for exact accuracy\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { FormulaEngine } from '../lib/excel-engine/formula-engine';\nimport { FormulaValidator, SheetValidationResult } from '../lib/excel-engine/formula-validator';\nimport { ExcelAnalysis } from '../lib/excel-engine/types';\n\ninterface TestResults {\n  totalFormulas: number;\n  passedFormulas: number;\n  failedFormulas: number;\n  skippedFormulas: number;\n  errors: TestError[];\n  warnings: TestWarning[];\n  performance: {\n    startTime: Date;\n    endTime: Date;\n    totalDurationMs: number;\n    averageFormulaTimeMs: number;\n  };\n  categoryBreakdown: Record<string, { total: number; passed: number; failed: number }>;\n}\n\ninterface TestError {\n  cellId: string;\n  formula: string;\n  expectedValue: any;\n  actualValue: any;\n  error: string;\n  category: string;\n}\n\ninterface TestWarning {\n  cellId: string;\n  message: string;\n  category: string;\n}\n\nclass ExcelParityTester {\n  private engine: FormulaEngine;\n  private validator: FormulaValidator;\n  private analysisData: ExcelAnalysis | null = null;\n  private knownResults: Map<string, any> = new Map();\n  private testResults: TestResults;\n\n  constructor() {\n    this.engine = new FormulaEngine({\n      maxIterations: 100,\n      epsilon: 1e-10,\n      enableArrayFormulas: true,\n      dateSystem: '1900',\n      calcMode: 'automatic'\n    });\n    \n    this.validator = new FormulaValidator(1e-10);\n    \n    this.testResults = {\n      totalFormulas: 0,\n      passedFormulas: 0,\n      failedFormulas: 0,\n      skippedFormulas: 0,\n      errors: [],\n      warnings: [],\n      performance: {\n        startTime: new Date(),\n        endTime: new Date(),\n        totalDurationMs: 0,\n        averageFormulaTimeMs: 0\n      },\n      categoryBreakdown: {}\n    };\n  }\n\n  /**\n   * Load Excel analysis data and known results\n   */\n  async loadTestData(): Promise<void> {\n    try {\n      console.log('Loading Excel analysis data...');\n      \n      // Load the analysis data\n      const analysisPath = path.join(__dirname, '../excel_analysis.json');\n      if (!fs.existsSync(analysisPath)) {\n        throw new Error(`Excel analysis file not found: ${analysisPath}`);\n      }\n      \n      const analysisRaw = fs.readFileSync(analysisPath, 'utf-8');\n      this.analysisData = JSON.parse(analysisRaw) as ExcelAnalysis;\n      \n      console.log(`Loaded ${this.analysisData.metadata.total_formulas} formulas from ${this.analysisData.metadata.sheet_count} sheets`);\n      \n      // Load the formula engine with analysis data\n      await this.engine.loadAnalysisData(this.analysisData);\n      \n      // Try to load known results if available\n      await this.loadKnownResults();\n      \n      console.log('Test data loaded successfully');\n    } catch (error) {\n      console.error('Failed to load test data:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Load known results from previous Excel exports or test runs\n   */\n  private async loadKnownResults(): Promise<void> {\n    const knownResultsPath = path.join(__dirname, '../test-data/known-results.json');\n    \n    if (fs.existsSync(knownResultsPath)) {\n      try {\n        const knownResultsRaw = fs.readFileSync(knownResultsPath, 'utf-8');\n        const knownResultsData = JSON.parse(knownResultsRaw);\n        \n        for (const [cellId, value] of Object.entries(knownResultsData)) {\n          this.knownResults.set(cellId, value);\n        }\n        \n        this.validator.loadKnownResults(knownResultsData);\n        console.log(`Loaded ${this.knownResults.size} known results for validation`);\n      } catch (error) {\n        console.warn('Could not load known results:', error);\n      }\n    } else {\n      console.log('No known results file found, will test without baseline comparison');\n    }\n  }\n\n  /**\n   * Run all parity tests\n   */\n  async runAllTests(): Promise<TestResults> {\n    if (!this.analysisData) {\n      throw new Error('Analysis data not loaded');\n    }\n\n    console.log('Starting Excel parity tests...');\n    this.testResults.performance.startTime = new Date();\n    \n    // Initialize category breakdown\n    for (const [category, count] of Object.entries(this.analysisData.metadata.category_summary)) {\n      this.testResults.categoryBreakdown[category] = {\n        total: count,\n        passed: 0,\n        failed: 0\n      };\n    }\n    \n    this.testResults.totalFormulas = this.analysisData.metadata.total_formulas;\n    \n    // Test each sheet\n    for (const [sheetName, formulas] of Object.entries(this.analysisData.formulas_by_sheet)) {\n      console.log(`Testing sheet: ${sheetName} (${formulas.length} formulas)`);\n      await this.testSheet(sheetName, formulas);\n    }\n    \n    // Calculate performance metrics\n    this.testResults.performance.endTime = new Date();\n    this.testResults.performance.totalDurationMs = \n      this.testResults.performance.endTime.getTime() - this.testResults.performance.startTime.getTime();\n    \n    if (this.testResults.totalFormulas > 0) {\n      this.testResults.performance.averageFormulaTimeMs = \n        this.testResults.performance.totalDurationMs / this.testResults.totalFormulas;\n    }\n    \n    console.log('Parity tests completed');\n    return this.testResults;\n  }\n\n  /**\n   * Test all formulas in a sheet\n   */\n  private async testSheet(sheetName: string, formulas: any[]): Promise<void> {\n    let processedCount = 0;\n    \n    for (const formulaData of formulas) {\n      try {\n        await this.testFormula(sheetName, formulaData);\n        processedCount++;\n        \n        // Progress logging\n        if (processedCount % 100 === 0) {\n          console.log(`  Processed ${processedCount}/${formulas.length} formulas`);\n        }\n      } catch (error) {\n        this.testResults.failedFormulas++;\n        this.testResults.errors.push({\n          cellId: `${sheetName}!${formulaData.cell}`,\n          formula: formulaData.formula,\n          expectedValue: null,\n          actualValue: null,\n          error: `Test execution failed: ${error}`,\n          category: formulaData.category || 'Unknown'\n        });\n      }\n    }\n  }\n\n  /**\n   * Test a single formula\n   */\n  private async testFormula(sheetName: string, formulaData: any): Promise<void> {\n    const cellId = `${sheetName}!${formulaData.cell}`;\n    const category = formulaData.category || 'Unknown';\n    \n    try {\n      // Calculate the formula\n      const startTime = Date.now();\n      const result = await this.engine.calculateCell(sheetName, formulaData.cell);\n      const endTime = Date.now();\n      \n      // Check for calculation errors\n      if (result.error) {\n        this.testResults.failedFormulas++;\n        this.testResults.categoryBreakdown[category].failed++;\n        \n        this.testResults.errors.push({\n          cellId,\n          formula: formulaData.formula,\n          expectedValue: null,\n          actualValue: result.value,\n          error: result.error,\n          category\n        });\n        return;\n      }\n      \n      // Validate against known results\n      const knownValue = this.knownResults.get(cellId);\n      const validationResult = await this.validator.validateResult(result.value, cellId, knownValue);\n      \n      if (validationResult.valid) {\n        this.testResults.passedFormulas++;\n        this.testResults.categoryBreakdown[category].passed++;\n      } else {\n        this.testResults.failedFormulas++;\n        this.testResults.categoryBreakdown[category].failed++;\n        \n        this.testResults.errors.push({\n          cellId,\n          formula: formulaData.formula,\n          expectedValue: knownValue,\n          actualValue: result.value,\n          error: validationResult.errors.join('; '),\n          category\n        });\n      }\n      \n      // Add warnings\n      for (const warning of validationResult.warnings) {\n        this.testResults.warnings.push({\n          cellId,\n          message: warning,\n          category\n        });\n      }\n      \n      // Performance warning for slow calculations\n      const calculationTime = endTime - startTime;\n      if (calculationTime > 100) { // 100ms threshold\n        this.testResults.warnings.push({\n          cellId,\n          message: `Slow calculation: ${calculationTime}ms`,\n          category: 'Performance'\n        });\n      }\n      \n    } catch (error) {\n      this.testResults.failedFormulas++;\n      this.testResults.categoryBreakdown[category].failed++;\n      \n      this.testResults.errors.push({\n        cellId,\n        formula: formulaData.formula,\n        expectedValue: null,\n        actualValue: null,\n        error: `Calculation failed: ${error}`,\n        category\n      });\n    }\n  }\n\n  /**\n   * Test specific formula categories\n   */\n  async testCategory(category: string): Promise<void> {\n    if (!this.analysisData) {\n      throw new Error('Analysis data not loaded');\n    }\n\n    console.log(`Testing category: ${category}`);\n    \n    for (const [sheetName, formulas] of Object.entries(this.analysisData.formulas_by_sheet)) {\n      const categoryFormulas = formulas.filter(f => f.category === category);\n      \n      if (categoryFormulas.length > 0) {\n        console.log(`  Testing ${categoryFormulas.length} ${category} formulas in ${sheetName}`);\n        \n        for (const formulaData of categoryFormulas) {\n          await this.testFormula(sheetName, formulaData);\n        }\n      }\n    }\n  }\n\n  /**\n   * Test specific cells\n   */\n  async testCells(cellIds: string[]): Promise<void> {\n    console.log(`Testing specific cells: ${cellIds.join(', ')}`);\n    \n    for (const cellId of cellIds) {\n      const [sheetName, cellRef] = cellId.split('!');\n      \n      if (!sheetName || !cellRef) {\n        console.warn(`Invalid cell ID format: ${cellId}`);\n        continue;\n      }\n      \n      // Find the formula data\n      const sheetFormulas = this.analysisData?.formulas_by_sheet[sheetName];\n      if (!sheetFormulas) {\n        console.warn(`Sheet not found: ${sheetName}`);\n        continue;\n      }\n      \n      const formulaData = sheetFormulas.find(f => f.cell === cellRef);\n      if (!formulaData) {\n        console.warn(`Formula not found: ${cellId}`);\n        continue;\n      }\n      \n      await this.testFormula(sheetName, formulaData);\n    }\n  }\n\n  /**\n   * Generate detailed test report\n   */\n  generateReport(): string {\n    const lines: string[] = [];\n    const { testResults } = this;\n    \n    lines.push('=== EXCEL PARITY TEST REPORT ===');\n    lines.push(`Generated: ${new Date().toISOString()}`);\n    lines.push('');\n    \n    // Summary\n    lines.push('=== SUMMARY ===');\n    lines.push(`Total Formulas: ${testResults.totalFormulas}`);\n    lines.push(`Passed: ${testResults.passedFormulas} (${((testResults.passedFormulas / testResults.totalFormulas) * 100).toFixed(2)}%)`);\n    lines.push(`Failed: ${testResults.failedFormulas} (${((testResults.failedFormulas / testResults.totalFormulas) * 100).toFixed(2)}%)`);\n    lines.push(`Skipped: ${testResults.skippedFormulas}`);\n    lines.push(`Errors: ${testResults.errors.length}`);\n    lines.push(`Warnings: ${testResults.warnings.length}`);\n    lines.push('');\n    \n    // Performance\n    lines.push('=== PERFORMANCE ===');\n    lines.push(`Total Duration: ${testResults.performance.totalDurationMs}ms`);\n    lines.push(`Average Formula Time: ${testResults.performance.averageFormulaTimeMs.toFixed(2)}ms`);\n    lines.push(`Start Time: ${testResults.performance.startTime.toISOString()}`);\n    lines.push(`End Time: ${testResults.performance.endTime.toISOString()}`);\n    lines.push('');\n    \n    // Category Breakdown\n    lines.push('=== CATEGORY BREAKDOWN ===');\n    for (const [category, stats] of Object.entries(testResults.categoryBreakdown)) {\n      const passRate = stats.total > 0 ? ((stats.passed / stats.total) * 100).toFixed(2) : '0.00';\n      lines.push(`${category}: ${stats.passed}/${stats.total} passed (${passRate}%), ${stats.failed} failed`);\n    }\n    lines.push('');\n    \n    // Top Errors\n    if (testResults.errors.length > 0) {\n      lines.push('=== TOP ERRORS ===');\n      const errorsByCategory: Record<string, number> = {};\n      \n      for (const error of testResults.errors) {\n        errorsByCategory[error.category] = (errorsByCategory[error.category] || 0) + 1;\n      }\n      \n      const sortedCategories = Object.entries(errorsByCategory)\n        .sort(([,a], [,b]) => b - a)\n        .slice(0, 10);\n      \n      for (const [category, count] of sortedCategories) {\n        lines.push(`${category}: ${count} errors`);\n      }\n      lines.push('');\n      \n      lines.push('=== FIRST 10 DETAILED ERRORS ===');\n      for (const error of testResults.errors.slice(0, 10)) {\n        lines.push(`${error.cellId} (${error.category}):`);\n        lines.push(`  Formula: ${error.formula}`);\n        lines.push(`  Expected: ${error.expectedValue}`);\n        lines.push(`  Actual: ${error.actualValue}`);\n        lines.push(`  Error: ${error.error}`);\n        lines.push('');\n      }\n    }\n    \n    // Warnings Summary\n    if (testResults.warnings.length > 0) {\n      lines.push('=== WARNINGS SUMMARY ===');\n      const warningsByCategory: Record<string, number> = {};\n      \n      for (const warning of testResults.warnings) {\n        warningsByCategory[warning.category] = (warningsByCategory[warning.category] || 0) + 1;\n      }\n      \n      for (const [category, count] of Object.entries(warningsByCategory)) {\n        lines.push(`${category}: ${count} warnings`);\n      }\n      lines.push('');\n    }\n    \n    return lines.join('\\n');\n  }\n\n  /**\n   * Save test results to file\n   */\n  async saveResults(outputDir: string = './test-results'): Promise<void> {\n    if (!fs.existsSync(outputDir)) {\n      fs.mkdirSync(outputDir, { recursive: true });\n    }\n    \n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    \n    // Save detailed results as JSON\n    const resultsPath = path.join(outputDir, `parity-test-results-${timestamp}.json`);\n    fs.writeFileSync(resultsPath, JSON.stringify(this.testResults, null, 2));\n    \n    // Save human-readable report\n    const reportPath = path.join(outputDir, `parity-test-report-${timestamp}.txt`);\n    fs.writeFileSync(reportPath, this.generateReport());\n    \n    // Save failed formulas for debugging\n    if (this.testResults.errors.length > 0) {\n      const errorsPath = path.join(outputDir, `failed-formulas-${timestamp}.json`);\n      fs.writeFileSync(errorsPath, JSON.stringify(this.testResults.errors, null, 2));\n    }\n    \n    console.log(`Results saved to ${outputDir}`);\n    console.log(`- Results: ${resultsPath}`);\n    console.log(`- Report: ${reportPath}`);\n    if (this.testResults.errors.length > 0) {\n      console.log(`- Errors: ${path.join(outputDir, `failed-formulas-${timestamp}.json`)}`);\n    }\n  }\n\n  /**\n   * Get test results\n   */\n  getResults(): TestResults {\n    return this.testResults;\n  }\n}\n\n// CLI interface\nasync function main() {\n  const args = process.argv.slice(2);\n  const command = args[0] || 'all';\n  \n  const tester = new ExcelParityTester();\n  \n  try {\n    await tester.loadTestData();\n    \n    switch (command) {\n      case 'all':\n        await tester.runAllTests();\n        break;\n        \n      case 'category':\n        const category = args[1];\n        if (!category) {\n          console.error('Please specify a category: Logical, Arithmetic, Math, Lookup, Text, Financial, Statistical');\n          process.exit(1);\n        }\n        await tester.testCategory(category);\n        break;\n        \n      case 'cells':\n        const cellIds = args.slice(1);\n        if (cellIds.length === 0) {\n          console.error('Please specify cell IDs (e.g., \"Ext Measure!B4\" \"Exterior Formula Sheet!B6\")');\n          process.exit(1);\n        }\n        await tester.testCells(cellIds);\n        break;\n        \n      default:\n        console.error('Unknown command. Use: all, category, or cells');\n        process.exit(1);\n    }\n    \n    // Generate and display report\n    const report = tester.generateReport();\n    console.log('');\n    console.log(report);\n    \n    // Save results\n    await tester.saveResults();\n    \n    const results = tester.getResults();\n    const exitCode = results.failedFormulas > 0 ? 1 : 0;\n    process.exit(exitCode);\n    \n  } catch (error) {\n    console.error('Test execution failed:', error);\n    process.exit(1);\n  }\n}\n\n// Export for programmatic use\nexport { ExcelParityTester, TestResults, TestError, TestWarning };\n\n// Run CLI if this script is executed directly\nif (require.main === module) {\n  main().catch(error => {\n    console.error('Unhandled error:', error);\n    process.exit(1);\n  });\n}
