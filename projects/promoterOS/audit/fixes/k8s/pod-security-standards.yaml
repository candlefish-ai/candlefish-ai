# Pod Security Standards - Restricted Profile - REMEDIATION CR-005
# Enforce security best practices for all pods

---
# Namespace with Pod Security Standards labels
apiVersion: v1
kind: Namespace
metadata:
  name: promoteros-api
  labels:
    name: promoteros-api
    # Enforce Pod Security Standards
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/enforce-version: latest
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/audit-version: latest
    pod-security.kubernetes.io/warn: restricted
    pod-security.kubernetes.io/warn-version: latest

---
apiVersion: v1
kind: Namespace
metadata:
  name: promoteros-data
  labels:
    name: promoteros-data
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/enforce-version: latest
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/audit-version: latest
    pod-security.kubernetes.io/warn: restricted
    pod-security.kubernetes.io/warn-version: latest

---
apiVersion: v1
kind: Namespace
metadata:
  name: promoteros-cache
  labels:
    name: promoteros-cache
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/enforce-version: latest
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/audit-version: latest
    pod-security.kubernetes.io/warn: restricted
    pod-security.kubernetes.io/warn-version: latest

---
# Security Context Constraint (for OpenShift compatibility)
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: restricted-psp
  annotations:
    seccomp.security.alpha.kubernetes.io/allowedProfileNames: 'runtime/default'
    apparmor.security.beta.kubernetes.io/allowedProfileNames: 'runtime/default'
    apparmor.security.beta.kubernetes.io/defaultProfileName:  'runtime/default'
spec:
  privileged: false
  allowPrivilegeEscalation: false
  requiredDropCapabilities:
  - ALL
  volumes:
  - 'configMap'
  - 'emptyDir'
  - 'projected'
  - 'secret'
  - 'downwardAPI'
  - 'persistentVolumeClaim'
  hostNetwork: false
  hostIPC: false
  hostPID: false
  runAsUser:
    rule: 'MustRunAsNonRoot'
  seLinux:
    rule: 'RunAsAny'
  supplementalGroups:
    rule: 'RunAsAny'
  fsGroup:
    rule: 'RunAsAny'
  readOnlyRootFilesystem: true

---
# ClusterRole for using the restricted PSP
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: restricted-psp-user
rules:
- apiGroups:
  - policy
  resources:
  - podsecuritypolicies
  verbs:
  - use
  resourceNames:
  - restricted-psp

---
# Bind the ClusterRole to all service accounts in promoteros namespaces
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: restricted-psp-all-serviceaccounts
roleRef:
  kind: ClusterRole
  name: restricted-psp-user
  apiGroup: rbac.authorization.k8s.io
subjects:
- kind: Group
  name: system:serviceaccounts:promoteros-api
  apiGroup: rbac.authorization.k8s.io
- kind: Group
  name: system:serviceaccounts:promoteros-data
  apiGroup: rbac.authorization.k8s.io
- kind: Group
  name: system:serviceaccounts:promoteros-cache
  apiGroup: rbac.authorization.k8s.io

---
# OPA Gatekeeper ConstraintTemplate for additional security
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srequiredsecuritycontext
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredSecurityContext
      validation:
        openAPIV3Schema:
          type: object
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequiredsecuritycontext
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not container.securityContext.runAsNonRoot
          msg := sprintf("Container %v must run as non-root", [container.name])
        }
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not container.securityContext.allowPrivilegeEscalation == false
          msg := sprintf("Container %v must not allow privilege escalation", [container.name])
        }
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not container.securityContext.readOnlyRootFilesystem
          msg := sprintf("Container %v must have read-only root filesystem", [container.name])
        }
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not container.securityContext.capabilities.drop[_] == "ALL"
          msg := sprintf("Container %v must drop ALL capabilities", [container.name])
        }

---
# Apply the constraint to promoteros namespaces
apiVersion: k8srequiredsecuritycontext.constraints.gatekeeper.sh/v1beta1
kind: K8sRequiredSecurityContext
metadata:
  name: must-have-security-context
spec:
  match:
    kinds:
    - apiGroups: ["apps"]
      kinds: ["Deployment", "StatefulSet", "DaemonSet"]
    namespaces:
    - promoteros-api
    - promoteros-data
    - promoteros-cache

---
# Kyverno Policy for automatic security context injection
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: inject-security-context
spec:
  background: false
  rules:
  - name: inject-container-security-context
    match:
      any:
      - resources:
          kinds:
          - Pod
          namespaces:
          - promoteros-*
    mutate:
      patchStrategicMerge:
        spec:
          securityContext:
            runAsNonRoot: true
            runAsUser: 1000
            fsGroup: 1000
            seccompProfile:
              type: RuntimeDefault
          containers:
          - (name): "*"
            securityContext:
              allowPrivilegeEscalation: false
              runAsNonRoot: true
              runAsUser: 1000
              readOnlyRootFilesystem: true
              capabilities:
                drop:
                - ALL

---
# ValidatingWebhookConfiguration for additional validation
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: pod-security-webhook
webhooks:
- name: pod-security.promoteros.io
  admissionReviewVersions: ["v1", "v1beta1"]
  clientConfig:
    service:
      name: pod-security-webhook
      namespace: promoteros-api
      path: "/validate"
    caBundle: LS0tLS1CRUdJTi... # Will be populated by cert-manager
  rules:
  - operations: ["CREATE", "UPDATE"]
    apiGroups: [""]
    apiVersions: ["v1"]
    resources: ["pods"]
    scope: "Namespaced"
  namespaceSelector:
    matchLabels:
      pod-security: "enforced"
  failurePolicy: Fail
  sideEffects: None
  timeoutSeconds: 10