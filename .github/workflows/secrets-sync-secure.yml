name: Secure Secrets Sync
# Secure implementation of secrets synchronization from AWS Secrets Manager

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Perform dry run without updating secrets'
        required: false
        default: true
        type: boolean
  schedule:
    # Run weekly on Monday at 3 AM UTC with jitter
    - cron: '0 3 * * 1'

# Minimal permissions
permissions:
  contents: read

jobs:
  sync-secrets:
    name: üîê Sync Secrets from AWS
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
      id-token: write  # For AWS OIDC
      secrets: write   # For updating GitHub secrets
    environment:
      name: secrets-management
    steps:
      - name: Checkout code
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11  # v4.1.1
        with:
          sparse-checkout: |
            .github/workflows
            scripts/secrets

      - name: Setup Node.js for GitHub API
        uses: actions/setup-node@v4
        with:
          node-version: '20.11.0'

      - name: Install dependencies
        run: |
          # Install only required packages with exact versions
          npm install tweetsodium@0.0.6 --save-exact --no-save

      - name: Configure AWS credentials (read-only secrets access)
        uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502  # v4.0.2
        with:
          role-to-assume: ${{ secrets.AWS_SECRETS_SYNC_ROLE_ARN }}
          aws-region: us-east-1
          role-session-name: GitHubActions-SecretsSync-${{ github.run_id }}
          mask-aws-account-id: true

      - name: Validate AWS permissions
        run: |
          set -euo pipefail

          # Verify we have the expected role
          ROLE_ARN=$(aws sts get-caller-identity --query Arn --output text)
          if [[ ! "$ROLE_ARN" =~ "secrets-sync" ]]; then
            echo "::error::Unexpected IAM role: $ROLE_ARN"
            exit 1
          fi

          # Verify we can only read secrets (not write)
          if aws secretsmanager create-secret --name test-write-check --secret-string test 2>/dev/null; then
            echo "::error::IAM role has write permissions to Secrets Manager (should be read-only)"
            aws secretsmanager delete-secret --secret-id test-write-check --force-delete-without-recovery
            exit 1
          fi

      - name: Fetch and process secrets
        id: fetch-secrets
        env:
          DRY_RUN: ${{ inputs.dry_run }}
        run: |
          set -euo pipefail

          # Define secrets to sync with validation patterns
          declare -A SECRETS_CONFIG=(
            ["candlefish/global/api-keys"]="^[A-Z_]+_API_KEY$"
            ["candlefish/global/database-credentials"]="^DB_[A-Z_]+$"
            ["candlefish/global/service-accounts"]="^SERVICE_[A-Z_]+$"
            ["candlefish/production/env-vars"]="^PROD_[A-Z_]+$"
            ["candlefish/staging/env-vars"]="^STAGING_[A-Z_]+$"
            ["candlefish/dev/env-vars"]="^DEV_[A-Z_]+$"
          )

          # Create secure temporary directory
          TEMP_DIR=$(mktemp -d)
          trap 'rm -rf "$TEMP_DIR"' EXIT

          # Set restrictive permissions
          chmod 700 "$TEMP_DIR"

          # Process each secret
          for secret_name in "${!SECRETS_CONFIG[@]}"; do
            echo "::group::Processing $secret_name"

            # Check if secret exists
            if ! aws secretsmanager describe-secret --secret-id "$secret_name" >/dev/null 2>&1; then
              echo "::warning::Secret not found: $secret_name"
              echo "::endgroup::"
              continue
            fi

            # Get secret metadata
            SECRET_METADATA=$(aws secretsmanager describe-secret --secret-id "$secret_name")
            LAST_CHANGED=$(echo "$SECRET_METADATA" | jq -r '.LastChangedDate')
            VERSION_ID=$(echo "$SECRET_METADATA" | jq -r '.VersionId')

            echo "Last changed: $LAST_CHANGED"
            echo "Version ID: $VERSION_ID"

            # Fetch secret value
            SECRET_VALUE=$(aws secretsmanager get-secret-value \
              --secret-id "$secret_name" \
              --version-id "$VERSION_ID" \
              --query SecretString \
              --output text)

            # Parse and validate each key-value pair
            echo "$SECRET_VALUE" | jq -r 'to_entries[] | "\(.key)=\(.value)"' | while IFS='=' read -r key value; do
              # Convert to GitHub-compatible format
              github_key=$(echo "${secret_name}_${key}" | tr '/' '_' | tr '-' '_' | tr '[:lower:]' '[:upper:]')

              # Validate key format
              pattern="${SECRETS_CONFIG[$secret_name]}"
              if [[ -n "$pattern" ]] && [[ ! "$github_key" =~ $pattern ]]; then
                echo "::warning::Key '$github_key' doesn't match expected pattern '$pattern'"
                continue
              fi

              # Mask the value
              echo "::add-mask::$value"

              # Store in encrypted format (in memory via process substitution)
              echo "$github_key" >> "$TEMP_DIR/keys.txt"

              # Use separate file descriptor for secure value storage
              exec 3>"$TEMP_DIR/${github_key}.enc"
              echo -n "$value" >&3
              exec 3>&-

              # Set restrictive permissions
              chmod 600 "$TEMP_DIR/${github_key}.enc"

              echo "‚úì Processed: $github_key (length: ${#value})"
            done

            echo "::endgroup::"
          done

          # Output summary
          if [[ -f "$TEMP_DIR/keys.txt" ]]; then
            KEY_COUNT=$(wc -l < "$TEMP_DIR/keys.txt")
            echo "keys_found=$KEY_COUNT" >> $GITHUB_OUTPUT
            echo "temp_dir=$TEMP_DIR" >> $GITHUB_OUTPUT
            echo "::notice::Found $KEY_COUNT secrets to sync"
          else
            echo "keys_found=0" >> $GITHUB_OUTPUT
            echo "::warning::No secrets found to sync"
          fi

      - name: Update GitHub Secrets
        if: steps.fetch-secrets.outputs.keys_found != '0'
        uses: actions/github-script@v7
        env:
          TEMP_DIR: ${{ steps.fetch-secrets.outputs.temp_dir }}
          DRY_RUN: ${{ inputs.dry_run }}
        with:
          script: |
            const fs = require('fs');
            const sodium = require('tweetsodium');
            const path = require('path');

            const isDryRun = process.env.DRY_RUN === 'true';
            const tempDir = process.env.TEMP_DIR;

            if (isDryRun) {
              console.log('üîç DRY RUN MODE - No secrets will be updated');
            }

            // Get repository public key for encryption
            const { data: publicKey } = await github.rest.actions.getRepoPublicKey({
              owner: context.repo.owner,
              repo: context.repo.repo
            });

            // Read keys to process
            const keysFile = path.join(tempDir, 'keys.txt');
            if (!fs.existsSync(keysFile)) {
              console.error('No keys file found');
              return;
            }

            const keys = fs.readFileSync(keysFile, 'utf8')
              .split('\n')
              .filter(key => key.trim());

            // Track results
            const results = {
              updated: [],
              failed: [],
              skipped: []
            };

            // Process each secret
            for (const secretName of keys) {
              try {
                // Read the encrypted value
                const valueFile = path.join(tempDir, `${secretName}.enc`);
                if (!fs.existsSync(valueFile)) {
                  console.warn(`Value file not found for ${secretName}`);
                  results.skipped.push(secretName);
                  continue;
                }

                const value = fs.readFileSync(valueFile, 'utf8');

                // Check if secret already exists
                let existingSecret = null;
                try {
                  existingSecret = await github.rest.actions.getRepoSecret({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    secret_name: secretName
                  });
                } catch (e) {
                  // Secret doesn't exist yet
                }

                if (isDryRun) {
                  const action = existingSecret ? 'UPDATE' : 'CREATE';
                  console.log(`[DRY RUN] Would ${action} secret: ${secretName}`);
                  results.skipped.push(secretName);
                  continue;
                }

                // Encrypt the secret value
                const messageBytes = Buffer.from(value);
                const keyBytes = Buffer.from(publicKey.key, 'base64');
                const encryptedBytes = sodium.seal(messageBytes, keyBytes);
                const encrypted = Buffer.from(encryptedBytes).toString('base64');

                // Create or update the secret
                await github.rest.actions.createOrUpdateRepoSecret({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  secret_name: secretName,
                  encrypted_value: encrypted,
                  key_id: publicKey.key_id
                });

                const action = existingSecret ? 'Updated' : 'Created';
                console.log(`‚úÖ ${action} secret: ${secretName}`);
                results.updated.push(secretName);

              } catch (error) {
                console.error(`‚ùå Failed to update secret: ${secretName}`, error.message);
                results.failed.push(secretName);
              }
            }

            // Generate summary
            console.log('\nüìä Summary:');
            console.log(`- Updated: ${results.updated.length}`);
            console.log(`- Failed: ${results.failed.length}`);
            console.log(`- Skipped: ${results.skipped.length}`);

            // Fail the job if any updates failed
            if (results.failed.length > 0 && !isDryRun) {
              core.setFailed(`Failed to update ${results.failed.length} secrets`);
            }

      - name: Cleanup and audit
        if: always()
        run: |
          set -euo pipefail

          # Securely cleanup temporary files
          if [[ -n "${TEMP_DIR:-}" ]] && [[ -d "$TEMP_DIR" ]]; then
            # Overwrite files before deletion
            find "$TEMP_DIR" -type f -exec shred -vfz {} \; 2>/dev/null || true
            rm -rf "$TEMP_DIR"
          fi

          # Create audit log entry
          AUDIT_LOG=$(cat <<EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "workflow": "secrets-sync",
            "run_id": "${{ github.run_id }}",
            "actor": "${{ github.actor }}",
            "event": "${{ github.event_name }}",
            "dry_run": ${{ inputs.dry_run || false }},
            "keys_processed": "${{ steps.fetch-secrets.outputs.keys_found }}",
            "status": "${{ job.status }}"
          }
          EOF
          )

          echo "::notice::Audit Log: $(echo "$AUDIT_LOG" | jq -c .)"

      - name: Send completion notification
        if: always()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          if [[ -n "${SLACK_WEBHOOK_URL:-}" ]] && [[ "${{ github.event_name }}" == "schedule" ]]; then
            STATUS_EMOJI="${{ job.status == 'success' && '‚úÖ' || '‚ùå' }}"
            DRY_RUN_TEXT="${{ inputs.dry_run && ' (DRY RUN)' || '' }}"

            curl -X POST "$SLACK_WEBHOOK_URL" \
              -H 'Content-Type: application/json' \
              -d '{
                "text": "'"${STATUS_EMOJI}"' Secrets Sync'"${DRY_RUN_TEXT}"'",
                "blocks": [{
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Status:* '"${{ job.status }}"'\n*Keys Processed:* '"${{ steps.fetch-secrets.outputs.keys_found }}"'\n*Run ID:* '"${{ github.run_id }}"'"
                  }
                }]
              }' || true
          fi

  # Validate secrets integrity
  validate-secrets:
    name: üîç Validate Secrets Integrity
    needs: [sync-secrets]
    if: success()
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      contents: read
      secrets: read
    steps:
      - name: Validate critical secrets exist
        run: |
          set -euo pipefail

          # Define critical secrets that must exist
          CRITICAL_SECRETS=(
            "AWS_GITHUB_DISCOVERY_ROLE_ARN"
            "AWS_SECRETS_SYNC_ROLE_ARN"
            "NETLIFY_AUTH_TOKEN"
            "NETLIFY_SITE_ID"
          )

          # Check each critical secret
          MISSING_SECRETS=()
          for secret in "${CRITICAL_SECRETS[@]}"; do
            # Try to reference the secret (will be masked)
            SECRET_VALUE="${!secret:-}"
            if [[ -z "$SECRET_VALUE" ]]; then
              MISSING_SECRETS+=("$secret")
            else
              echo "‚úÖ Critical secret exists: $secret"
            fi
          done

          # Report missing secrets
          if [[ ${#MISSING_SECRETS[@]} -gt 0 ]]; then
            echo "::error::Missing critical secrets: ${MISSING_SECRETS[*]}"
            exit 1
          fi

          echo "::notice::All critical secrets validated successfully"

      - name: Test secret usability
        env:
          TEST_SECRET: ${{ secrets.AWS_GITHUB_DISCOVERY_ROLE_ARN }}
        run: |
          set -euo pipefail

          # Verify secret is properly formatted (for ARN)
          if [[ "$TEST_SECRET" =~ ^arn:aws:iam::[0-9]+:role/.+ ]]; then
            echo "‚úÖ Secret format validation passed"
          else
            echo "::error::Secret format validation failed"
            exit 1
          fi
