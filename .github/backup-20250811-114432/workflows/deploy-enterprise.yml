name: Deploy Enterprise Application
# Optimized deployment for containerized enterprise projects

on:
  workflow_call:
    inputs:
      project:
        required: true
        type: string
        description: 'Enterprise project (cfpaint, cffogg, cfprom, cfbrew)'
      environment:
        required: true
        type: string
        description: 'Environment (dev, staging, production)'
      ref:
        required: false
        type: string
        default: ''
    secrets:
      AWS_ACCOUNT_ID:
        required: true
      ECR_REGISTRY:
        required: true
      ECS_CLUSTER:
        required: true

permissions:
  contents: read
  id-token: write
  deployments: write

env:
  NODE_VERSION: '20'
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

jobs:
  deploy:
    name: Deploy ${{ inputs.project }} to ECS
    runs-on: ubuntu-latest-8-cores  # Larger runner for container builds
    timeout-minutes: 30
    environment:
      name: ${{ inputs.environment }}
      url: https://${{ inputs.project }}.candlefish.ai

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref || github.ref }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-deploy-${{ inputs.environment }}
          aws-region: us-east-1

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            network=host
            image=moby/buildkit:v0.12.0
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Determine project path
        id: project-path
        run: |
          case "${{ inputs.project }}" in
            cfpaint) echo "path=projects/paintbox" >> $GITHUB_OUTPUT ;;
            cffogg) echo "path=projects/fogg" >> $GITHUB_OUTPUT ;;
            cfprom) echo "path=projects/promoterOS" >> $GITHUB_OUTPUT ;;
            cfbrew) echo "path=projects/brewery" >> $GITHUB_OUTPUT ;;
          esac

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ${{ steps.project-path.outputs.path }}
          file: ${{ steps.project-path.outputs.path }}/Dockerfile
          push: true
          tags: |
            ${{ secrets.ECR_REGISTRY }}/${{ inputs.project }}:${{ github.sha }}
            ${{ secrets.ECR_REGISTRY }}/${{ inputs.project }}:${{ inputs.environment }}
            ${{ secrets.ECR_REGISTRY }}/${{ inputs.project }}:latest
          cache-from: |
            type=gha
            type=registry,ref=${{ secrets.ECR_REGISTRY }}/${{ inputs.project }}:buildcache
          cache-to: |
            type=gha,mode=max
            type=registry,ref=${{ secrets.ECR_REGISTRY }}/${{ inputs.project }}:buildcache,mode=max
          build-args: |
            NODE_ENV=${{ inputs.environment }}
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}
            VERSION=${{ github.ref_name }}

      - name: Create ECS task definition
        id: task-def
        run: |
          # Create task definition with proper resource allocation
          case "${{ inputs.project }}" in
            cfprom)
              CPU="2048"
              MEMORY="4096"
              ;;
            *)
              CPU="1024"
              MEMORY="2048"
              ;;
          esac

          cat > task-definition.json <<EOF
          {
            "family": "${{ inputs.project }}-${{ inputs.environment }}",
            "networkMode": "awsvpc",
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "${CPU}",
            "memory": "${MEMORY}",
            "containerDefinitions": [
              {
                "name": "${{ inputs.project }}",
                "image": "${{ secrets.ECR_REGISTRY }}/${{ inputs.project }}:${{ github.sha }}",
                "essential": true,
                "portMappings": [
                  {
                    "containerPort": 3000,
                    "protocol": "tcp"
                  }
                ],
                "environment": [
                  {
                    "name": "NODE_ENV",
                    "value": "${{ inputs.environment }}"
                  },
                  {
                    "name": "PORT",
                    "value": "3000"
                  }
                ],
                "logConfiguration": {
                  "logDriver": "awslogs",
                  "options": {
                    "awslogs-group": "/ecs/${{ inputs.project }}-${{ inputs.environment }}",
                    "awslogs-region": "us-east-1",
                    "awslogs-stream-prefix": "ecs"
                  }
                },
                "healthCheck": {
                  "command": ["CMD-SHELL", "curl -f http://localhost:3000/health || exit 1"],
                  "interval": 30,
                  "timeout": 5,
                  "retries": 3,
                  "startPeriod": 60
                }
              }
            ]
          }
          EOF

          # Register task definition
          aws ecs register-task-definition --cli-input-json file://task-definition.json

      - name: Deploy to ECS Fargate
        run: |
          # Update service with new task definition
          aws ecs update-service \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --service ${{ inputs.project }}-${{ inputs.environment }} \
            --force-new-deployment \
            --task-definition ${{ inputs.project }}-${{ inputs.environment }} \
            --desired-count ${{ inputs.environment == 'production' && '3' || '1' }}

          # Wait for deployment to complete
          aws ecs wait services-stable \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --services ${{ inputs.project }}-${{ inputs.environment }}

      - name: Run smoke tests
        run: |
          # Get service endpoint
          TASK_ARN=$(aws ecs list-tasks \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --service-name ${{ inputs.project }}-${{ inputs.environment }} \
            --query 'taskArns[0]' \
            --output text)

          ENI_ID=$(aws ecs describe-tasks \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --tasks $TASK_ARN \
            --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' \
            --output text)

          PUBLIC_IP=$(aws ec2 describe-network-interfaces \
            --network-interface-ids $ENI_ID \
            --query 'NetworkInterfaces[0].Association.PublicIp' \
            --output text)

          # Test health endpoint
          for i in {1..10}; do
            if curl -f "http://${PUBLIC_IP}:3000/health"; then
              echo "✅ Service is healthy"
              break
            else
              echo "⏳ Waiting for service... (attempt $i/10)"
              sleep 30
            fi
          done

      - name: Configure auto-scaling
        if: inputs.environment == 'production'
        run: |
          # Register scalable target
          aws application-autoscaling register-scalable-target \
            --service-namespace ecs \
            --resource-id service/${{ secrets.ECS_CLUSTER }}/${{ inputs.project }}-${{ inputs.environment }} \
            --scalable-dimension ecs:service:DesiredCount \
            --min-capacity 2 \
            --max-capacity 10

          # Create scaling policy
          aws application-autoscaling put-scaling-policy \
            --service-namespace ecs \
            --resource-id service/${{ secrets.ECS_CLUSTER }}/${{ inputs.project }}-${{ inputs.environment }} \
            --scalable-dimension ecs:service:DesiredCount \
            --policy-name ${{ inputs.project }}-cpu-scaling \
            --policy-type TargetTrackingScaling \
            --target-tracking-scaling-policy-configuration '{
              "TargetValue": 70.0,
              "PredefinedMetricSpecification": {
                "PredefinedMetricType": "ECSServiceAverageCPUUtilization"
              },
              "ScaleOutCooldown": 60,
              "ScaleInCooldown": 180
            }'

      - name: Update deployment status
        if: always()
        run: |
          STATUS="${{ job.status == 'success' && '✅' || '❌' }}"
          echo "## $STATUS Deployment Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Project:** ${{ inputs.project }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image:** ${{ secrets.ECR_REGISTRY }}/${{ inputs.project }}:${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Cluster:** ${{ secrets.ECS_CLUSTER }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status:** ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
