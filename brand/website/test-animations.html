<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Candlefish Animation Test</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #0D1B2A;
            color: #F8F8F2;
            font-family: system-ui, -apple-system, sans-serif;
        }
        .test-section {
            margin-bottom: 40px;
            padding: 20px;
            border: 1px solid #415A77;
            border-radius: 8px;
        }
        .test-result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .success { background: rgba(63, 211, 198, 0.2); color: #3FD3C6; }
        .error { background: rgba(255, 107, 107, 0.2); color: #FF6B6B; }
        .warning { background: rgba(255, 206, 84, 0.2); color: #FFCE54; }

        /* HeaderText Test */
        .header-test {
            position: relative;
            height: 100px;
            overflow: hidden;
        }

        /* SystemActivity Test */
        .activity-test {
            position: relative;
            height: 4px;
            width: 100%;
            background: #1B263B;
        }

        /* WebGL Test */
        .webgl-test {
            width: 100%;
            height: 300px;
            background: #1B263B;
            position: relative;
        }
    </style>
</head>
<body>
    <h1>Candlefish Animation Test Suite</h1>
    <p>Testing animation components functionality and performance</p>

    <div class="test-section">
        <h2>1. HeaderText Rotation Test</h2>
        <div class="header-test">
            <div id="headerTextTest">Currently engineering<br><span id="rotatingText">operational excellence systems</span></div>
        </div>
        <div id="headerResult" class="test-result">Testing...</div>
    </div>

    <div class="test-section">
        <h2>2. SystemActivity Bars Test</h2>
        <div class="activity-test">
            <canvas id="activityCanvas" width="800" height="4" style="width: 100%; height: 100%;"></canvas>
        </div>
        <div id="activityResult" class="test-result">Testing...</div>
    </div>

    <div class="test-section">
        <h2>3. WebGL Support Test</h2>
        <div class="webgl-test">
            <canvas id="webglCanvas" width="400" height="300" style="width: 100%; height: 100%;"></canvas>
        </div>
        <div id="webglResult" class="test-result">Testing...</div>
    </div>

    <div class="test-section">
        <h2>4. Performance Test</h2>
        <div id="performanceResult" class="test-result">Testing...</div>
    </div>

    <div class="test-section">
        <h2>5. Browser Compatibility Test</h2>
        <div id="compatResult" class="test-result">Testing...</div>
    </div>

    <script>
        // Animation test data
        const projects = [
            'engraving automation for a trophy franchise network',
            'concert intelligence platform for live music venues',
            'inventory management system for real estate operations',
            'excel-to-web platform for construction estimating'
        ];

        let currentProjectIndex = 0;
        let animationFrameId;

        // 1. HeaderText Rotation Test
        function testHeaderRotation() {
            const textElement = document.getElementById('rotatingText');
            const resultElement = document.getElementById('headerResult');

            let rotationCount = 0;
            const rotationInterval = setInterval(() => {
                currentProjectIndex = (currentProjectIndex + 1) % projects.length;
                textElement.style.opacity = '0.6';
                textElement.style.filter = 'blur(1px)';

                setTimeout(() => {
                    textElement.textContent = projects[currentProjectIndex];
                    textElement.style.opacity = '1';
                    textElement.style.filter = 'blur(0)';
                    rotationCount++;

                    if (rotationCount >= 2) {
                        clearInterval(rotationInterval);
                        resultElement.className = 'test-result success';
                        resultElement.textContent = '✓ HeaderText rotation working - projects rotate every 5 seconds with blur transition';
                    }
                }, 400);
            }, 2000); // Faster for testing

            setTimeout(() => {
                if (rotationCount === 0) {
                    resultElement.className = 'test-result error';
                    resultElement.textContent = '✗ HeaderText rotation failed - no transitions detected';
                }
            }, 5000);
        }

        // 2. SystemActivity Bars Test
        function testSystemActivity() {
            const canvas = document.getElementById('activityCanvas');
            const ctx = canvas.getContext('2d');
            const resultElement = document.getElementById('activityResult');

            if (!ctx) {
                resultElement.className = 'test-result error';
                resultElement.textContent = '✗ Canvas context not available';
                return;
            }

            const barCount = 30;
            const activity = Array.from({ length: barCount }, () => Math.random() * 0.6 + 0.2);
            let frameCount = 0;

            function renderBars(timestamp) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const barWidth = canvas.width / barCount;
                const actualBarWidth = barWidth * 0.3;
                const maxHeight = 2;

                ctx.fillStyle = 'rgba(65, 90, 119, 0.25)';

                activity.forEach((baseValue, i) => {
                    const noiseValue = Math.sin(i * 0.3 + timestamp * 0.0008) * 0.15;
                    const value = Math.max(0.1, Math.min(1, baseValue + noiseValue));
                    const height = value * maxHeight;
                    const x = i * barWidth + (barWidth - actualBarWidth) / 2;
                    const y = (canvas.height - height) / 2;

                    ctx.fillRect(x, y, actualBarWidth, height);
                });

                frameCount++;
                if (frameCount < 60) {
                    animationFrameId = requestAnimationFrame(renderBars);
                } else {
                    resultElement.className = 'test-result success';
                    resultElement.textContent = `✓ SystemActivity bars working - rendered ${frameCount} frames smoothly`;
                }
            }

            animationFrameId = requestAnimationFrame(renderBars);

            setTimeout(() => {
                if (frameCount < 10) {
                    resultElement.className = 'test-result error';
                    resultElement.textContent = '✗ SystemActivity animation failed - insufficient frames rendered';
                }
            }, 3000);
        }

        // 3. WebGL Support Test
        function testWebGLSupport() {
            const canvas = document.getElementById('webglCanvas');
            const resultElement = document.getElementById('webglResult');

            try {
                const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');

                if (!gl) {
                    resultElement.className = 'test-result error';
                    resultElement.textContent = '✗ WebGL not supported - SystemArchitecture will use fallback';
                    return;
                }

                // Test basic WebGL functionality
                gl.clearColor(0.05, 0.11, 0.17, 1.0); // #0D1B2A
                gl.clear(gl.COLOR_BUFFER_BIT);

                // Create simple shader program
                const vertexShader = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vertexShader, `
                    attribute vec2 position;
                    void main() {
                        gl_Position = vec4(position, 0.0, 1.0);
                        gl_PointSize = 3.0;
                    }
                `);
                gl.compileShader(vertexShader);

                const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fragmentShader, `
                    precision mediump float;
                    void main() {
                        gl_FragColor = vec4(0.25, 0.83, 0.78, 0.7); // #3FD3C6
                    }
                `);
                gl.compileShader(fragmentShader);

                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                gl.useProgram(program);

                // Draw test points (simulating particles)
                const positions = [];
                for (let i = 0; i < 20; i++) {
                    positions.push((Math.random() - 0.5) * 2);
                    positions.push((Math.random() - 0.5) * 2);
                }

                const buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

                const positionLocation = gl.getAttribLocation(program, 'position');
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

                gl.drawArrays(gl.POINTS, 0, positions.length / 2);

                resultElement.className = 'test-result success';
                resultElement.textContent = '✓ WebGL working - SystemArchitecture particle system will render properly';

            } catch (error) {
                resultElement.className = 'test-result error';
                resultElement.textContent = `✗ WebGL test failed: ${error.message}`;
            }
        }

        // 4. Performance Test
        function testPerformance() {
            const resultElement = document.getElementById('performanceResult');

            const start = performance.now();
            let frameCount = 0;

            function performanceLoop() {
                frameCount++;
                if (frameCount < 60) {
                    requestAnimationFrame(performanceLoop);
                } else {
                    const end = performance.now();
                    const avgFrameTime = (end - start) / frameCount;
                    const fps = 1000 / avgFrameTime;

                    if (fps >= 55) {
                        resultElement.className = 'test-result success';
                        resultElement.textContent = `✓ Performance excellent - ${fps.toFixed(1)} FPS average`;
                    } else if (fps >= 30) {
                        resultElement.className = 'test-result warning';
                        resultElement.textContent = `⚠ Performance adequate - ${fps.toFixed(1)} FPS average`;
                    } else {
                        resultElement.className = 'test-result error';
                        resultElement.textContent = `✗ Performance poor - ${fps.toFixed(1)} FPS average`;
                    }
                }
            }

            requestAnimationFrame(performanceLoop);
        }

        // 5. Browser Compatibility Test
        function testCompatibility() {
            const resultElement = document.getElementById('compatResult');
            const features = [];

            // Test ES6+ features
            try {
                new Function('const a = () => {}; let b; const c = {...{}}; async function d() {}')();
                features.push('✓ ES6+ syntax supported');
            } catch (e) {
                features.push('✗ ES6+ syntax not supported');
            }

            // Test canvas support
            if (document.createElement('canvas').getContext) {
                features.push('✓ Canvas API supported');
            } else {
                features.push('✗ Canvas API not supported');
            }

            // Test requestAnimationFrame
            if (window.requestAnimationFrame) {
                features.push('✓ requestAnimationFrame supported');
            } else {
                features.push('✗ requestAnimationFrame not supported');
            }

            // Test CSS transitions
            const testEl = document.createElement('div');
            testEl.style.transition = 'opacity 1s';
            if (testEl.style.transition) {
                features.push('✓ CSS transitions supported');
            } else {
                features.push('✗ CSS transitions not supported');
            }

            // Test reduced motion preference
            const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
            if (prefersReducedMotion) {
                features.push('⚠ User prefers reduced motion - animations will be minimal');
            } else {
                features.push('✓ Full animations enabled');
            }

            const allSupported = features.every(f => f.startsWith('✓'));
            resultElement.className = allSupported ? 'test-result success' : 'test-result warning';
            resultElement.innerHTML = features.join('<br>');
        }

        // Run all tests
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(testHeaderRotation, 500);
            setTimeout(testSystemActivity, 1000);
            setTimeout(testWebGLSupport, 1500);
            setTimeout(testPerformance, 2000);
            setTimeout(testCompatibility, 100);
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        });
    </script>
</body>
</html>
