apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: rtpm-timescaledb
  namespace: rtpm-system
  labels:
    app.kubernetes.io/name: rtpm
    app.kubernetes.io/component: database
    app.kubernetes.io/instance: timescaledb
spec:
  serviceName: rtpm-timescaledb
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: rtpm
      app.kubernetes.io/component: database
      app.kubernetes.io/instance: timescaledb
  template:
    metadata:
      labels:
        app.kubernetes.io/name: rtpm
        app.kubernetes.io/component: database
        app.kubernetes.io/instance: timescaledb
    spec:
      securityContext:
        fsGroup: 999
        runAsUser: 999
        runAsGroup: 999
      containers:
      - name: timescaledb
        image: timescale/timescaledb:latest-pg15
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 5432
          name: postgres
        env:
        - name: POSTGRES_DB
          valueFrom:
            configMapKeyRef:
              name: rtpm-config
              key: DATABASE_NAME
        - name: POSTGRES_USER
          valueFrom:
            configMapKeyRef:
              name: rtpm-config
              key: DATABASE_USER
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: rtpm-secrets
              key: DATABASE_PASSWORD
        - name: PGDATA
          value: /var/lib/postgresql/data/pgdata
        - name: TIMESCALEDB_TELEMETRY
          value: "off"
        resources:
          requests:
            cpu: 500m
            memory: 1Gi
          limits:
            cpu: 2
            memory: 4Gi
        volumeMounts:
        - name: postgres-storage
          mountPath: /var/lib/postgresql/data
        - name: init-scripts
          mountPath: /docker-entrypoint-initdb.d
          readOnly: true
        - name: tmp
          mountPath: /tmp
        - name: run
          mountPath: /var/run/postgresql
        livenessProbe:
          exec:
            command:
            - /bin/sh
            - -c
            - pg_isready -U $POSTGRES_USER -d $POSTGRES_DB
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        readinessProbe:
          exec:
            command:
            - /bin/sh
            - -c
            - pg_isready -U $POSTGRES_USER -d $POSTGRES_DB
          initialDelaySeconds: 5
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
      volumes:
      - name: init-scripts
        configMap:
          name: timescaledb-init
      - name: tmp
        emptyDir: {}
      - name: run
        emptyDir: {}
  volumeClaimTemplates:
  - metadata:
      name: postgres-storage
    spec:
      accessModes: ["ReadWriteOnce"]
      storageClassName: rtpm-ssd
      resources:
        requests:
          storage: 100Gi
---
apiVersion: v1
kind: Service
metadata:
  name: rtpm-timescaledb
  namespace: rtpm-system
  labels:
    app.kubernetes.io/name: rtpm
    app.kubernetes.io/component: database
    app.kubernetes.io/instance: timescaledb
spec:
  type: ClusterIP
  ports:
  - port: 5432
    targetPort: 5432
    protocol: TCP
    name: postgres
  selector:
    app.kubernetes.io/name: rtpm
    app.kubernetes.io/component: database
    app.kubernetes.io/instance: timescaledb
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: timescaledb-init
  namespace: rtpm-system
  labels:
    app.kubernetes.io/name: rtpm
    app.kubernetes.io/component: database-init
data:
  01-init.sql: |
    -- Initialize TimescaleDB extension
    CREATE EXTENSION IF NOT EXISTS timescaledb;

    -- Create database schemas
    CREATE SCHEMA IF NOT EXISTS metrics;
    CREATE SCHEMA IF NOT EXISTS agents;
    CREATE SCHEMA IF NOT EXISTS monitoring;

    -- Create agent_metrics hypertable
    CREATE TABLE IF NOT EXISTS metrics.agent_metrics (
        id BIGSERIAL PRIMARY KEY,
        agent_id UUID NOT NULL,
        metric_name VARCHAR(100) NOT NULL,
        metric_value DOUBLE PRECISION NOT NULL,
        tags JSONB,
        timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    SELECT create_hypertable('metrics.agent_metrics', 'timestamp', if_not_exists => TRUE);

    -- Create indexes for performance
    CREATE INDEX IF NOT EXISTS idx_agent_metrics_agent_id ON metrics.agent_metrics (agent_id, timestamp DESC);
    CREATE INDEX IF NOT EXISTS idx_agent_metrics_name ON metrics.agent_metrics (metric_name, timestamp DESC);
    CREATE INDEX IF NOT EXISTS idx_agent_metrics_tags ON metrics.agent_metrics USING GIN (tags);

    -- Create agents table
    CREATE TABLE IF NOT EXISTS agents.agents (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        name VARCHAR(255) NOT NULL,
        type VARCHAR(100) NOT NULL,
        status VARCHAR(50) NOT NULL DEFAULT 'inactive',
        metadata JSONB,
        created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    -- Create monitoring tables
    CREATE TABLE IF NOT EXISTS monitoring.system_metrics (
        id BIGSERIAL PRIMARY KEY,
        metric_type VARCHAR(100) NOT NULL,
        value DOUBLE PRECISION NOT NULL,
        labels JSONB,
        timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    SELECT create_hypertable('monitoring.system_metrics', 'timestamp', if_not_exists => TRUE);

    -- Set up retention policies (keep data for 30 days)
    SELECT add_retention_policy('metrics.agent_metrics', INTERVAL '30 days', if_not_exists => TRUE);
    SELECT add_retention_policy('monitoring.system_metrics', INTERVAL '30 days', if_not_exists => TRUE);

    -- Create continuous aggregates for performance
    CREATE MATERIALIZED VIEW IF NOT EXISTS metrics.agent_metrics_hourly
    WITH (timescaledb.continuous) AS
    SELECT agent_id,
           metric_name,
           time_bucket('1 hour', timestamp) AS hour,
           AVG(metric_value) AS avg_value,
           MAX(metric_value) AS max_value,
           MIN(metric_value) AS min_value,
           COUNT(*) AS count
    FROM metrics.agent_metrics
    GROUP BY agent_id, metric_name, hour
    WITH NO DATA;

    -- Refresh policy for continuous aggregate
    SELECT add_continuous_aggregate_policy('metrics.agent_metrics_hourly',
        start_offset => INTERVAL '3 hours',
        end_offset => INTERVAL '1 hour',
        schedule_interval => INTERVAL '1 hour',
        if_not_exists => TRUE);
